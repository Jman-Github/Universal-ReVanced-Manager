package app.revanced.manager.ui.component.bundle

import android.net.Uri
import android.os.Build
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.Search
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import app.universal.revanced.manager.R
import app.revanced.manager.domain.bundles.PatchBundleSource
import app.revanced.manager.domain.manager.PreferencesManager
import app.revanced.manager.domain.repository.PatchBundleRepository
import app.revanced.manager.patcher.patch.PatchInfo
import app.revanced.manager.ui.component.ArrowButton
import app.revanced.manager.ui.component.FullscreenDialog
import app.revanced.manager.ui.component.LazyColumnWithScrollbar
import app.revanced.manager.util.openUrl
import kotlinx.coroutines.flow.mapNotNull
import org.koin.compose.koinInject

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun BundlePatchesDialog(
    onDismissRequest: () -> Unit,
    src: PatchBundleSource,
) {
    val patchBundleRepository: PatchBundleRepository = koinInject()
    val prefs: PreferencesManager = koinInject()
    val searchEngineHost by prefs.searchEngineHost.getAsState()
    var query by rememberSaveable(src.uid, "patches_query") { mutableStateOf("") }
    val patches by remember(src.uid) {
        patchBundleRepository.allBundlesInfoFlow.mapNotNull { it[src.uid]?.patches }
    }.collectAsStateWithLifecycle(emptyList())
    val filteredPatches = remember(patches, query) {
        val trimmed = query.trim()
        if (trimmed.isBlank()) {
            patches
        } else {
            patches.filter { it.matchesQuery(trimmed) }
        }
    }

    FullscreenDialog(
        onDismissRequest = onDismissRequest,
    ) {
        Scaffold(
            topBar = {
                BundleTopBar(
                    title = stringResource(R.string.patches),
                    onBackClick = onDismissRequest,
                    backIcon = {
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = stringResource(R.string.back)
                        )
                    },
                )
            },
        ) { paddingValues ->
            LazyColumnWithScrollbar(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(paddingValues),
                verticalArrangement = Arrangement.spacedBy(12.dp),
                contentPadding = PaddingValues(16.dp)
            ) {
                item(key = "patches_search") {
                    OutlinedTextField(
                        modifier = Modifier.fillMaxWidth(),
                        value = query,
                        onValueChange = { query = it },
                        singleLine = true,
                        placeholder = { Text(stringResource(R.string.search_patches)) },
                        leadingIcon = {
                            Icon(
                                imageVector = Icons.Outlined.Search,
                                contentDescription = stringResource(R.string.search)
                            )
                        },
                        trailingIcon = {
                            if (query.isNotEmpty()) {
                                IconButton(onClick = { query = "" }) {
                                    Icon(
                                        imageVector = Icons.Outlined.Close,
                                        contentDescription = stringResource(R.string.clear)
                                    )
                                }
                            }
                        }
                    )
                }
                if (filteredPatches.isEmpty() && query.isNotBlank()) {
                    item(key = "patches_search_empty") {
                        Text(
                            text = stringResource(R.string.search_no_results),
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                } else {
                    itemsIndexed(
                        items = filteredPatches,
                        key = { index, patch -> src.uid to (patch.name + "-" + index) }
                    ) { _, patch ->
                        var expandVersions by rememberSaveable(src.uid, patch.name, "versions") { mutableStateOf(false) }
                        var expandOptions by rememberSaveable(src.uid, patch.name, "options") { mutableStateOf(false) }

                        PatchItem(
                            patch,
                            expandVersions,
                            onExpandVersions = { expandVersions = !expandVersions },
                            expandOptions,
                            onExpandOptions = { expandOptions = !expandOptions },
                            searchEngineHost = searchEngineHost
                        )
                    }
                }
            }
        }
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PatchItem(
    patch: PatchInfo,
    expandVersions: Boolean,
    onExpandVersions: () -> Unit,
    expandOptions: Boolean,
    onExpandOptions: () -> Unit,
    searchEngineHost: String,
    showCompatibilityMeta: Boolean = true,
    showOptionValues: Boolean = false,
    optionValues: Map<String, Any?>? = null
) {
    val context = LocalContext.current
    ElevatedCard(
        modifier = Modifier
            .fillMaxWidth()
            .then(
                if (patch.options.isNullOrEmpty()) Modifier else Modifier
                    .clip(RoundedCornerShape(8.dp))
                    .clickable(onClick = onExpandOptions),
            )
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(6.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Absolute.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = patch.name,
                    color = MaterialTheme.colorScheme.primary,
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold
                )

                if (!patch.options.isNullOrEmpty()) {
                    ArrowButton(expanded = expandOptions, onClick = null)
                }
            }
            patch.description?.let {
                Text(
                    text = it,
                    style = MaterialTheme.typography.bodyMedium
                )
            }
            if (showCompatibilityMeta) {
                Column(
                    verticalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    if (patch.compatiblePackages.isNullOrEmpty()) {
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(4.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            PatchInfoChip(
                                text = "$PACKAGE_ICON ${stringResource(R.string.patches_view_any_package)}"
                            )
                            PatchInfoChip(
                                text = "$VERSION_ICON ${stringResource(R.string.patches_view_any_version)}",
                                onClick = {
                                    val packageName = patch.compatiblePackages
                                        ?.firstOrNull()
                                        ?.packageName
                                        ?.takeIf { it.isNotBlank() }
                                        ?: "android.app"
                                    context.openUrl(buildSearchUrl(packageName, null, searchEngineHost))
                                }
                            )
                        }
                    } else {
                        patch.compatiblePackages.forEach { compatiblePackage ->
                            val packageName = compatiblePackage.packageName
                            val versions = compatiblePackage.versions.orEmpty().reversed()

                            FlowRow(
                                horizontalArrangement = Arrangement.spacedBy(4.dp),
                                verticalArrangement = Arrangement.spacedBy(4.dp)
                            ) {
                                PatchInfoChip(
                                    modifier = Modifier.align(Alignment.CenterVertically),
                                    text = "$PACKAGE_ICON $packageName"
                                )

                                if (versions.isNotEmpty()) {
                                    if (expandVersions) {
                                        versions.forEach { version ->
                                            PatchInfoChip(
                                                modifier = Modifier.align(Alignment.CenterVertically),
                                                text = "$VERSION_ICON $version",
                                                onClick = {
                                                    context.openUrl(
                                                        buildSearchUrl(packageName, version, searchEngineHost)
                                                    )
                                                }
                                            )
                                        }
                                    } else {
                                        PatchInfoChip(
                                            modifier = Modifier.align(Alignment.CenterVertically),
                                            text = "$VERSION_ICON ${versions.first()}",
                                            onClick = {
                                                context.openUrl(
                                                    buildSearchUrl(packageName, versions.first(), searchEngineHost)
                                                )
                                            }
                                        )
                                    }
                                    if (versions.size > 1) {
                                        PatchInfoChip(
                                            onClick = onExpandVersions,
                                            text = if (expandVersions) stringResource(R.string.less) else "+${versions.size - 1}"
                                        )
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (!patch.options.isNullOrEmpty()) {
                AnimatedVisibility(visible = expandOptions) {
                    val options = patch.options

                    Column {
                        options.forEachIndexed { i, option ->
                            val resolvedValue = optionValues?.get(option.key) ?: option.default
                            val presetLabel = option.presets
                                ?.entries
                                ?.firstOrNull { it.value == resolvedValue }
                                ?.key
                            OutlinedCard(
                                modifier = Modifier.fillMaxWidth(),
                                colors = CardColors(
                                    containerColor = Color.Transparent,
                                    contentColor = MaterialTheme.colorScheme.onSurface,
                                    disabledContainerColor = Color.Transparent,
                                    disabledContentColor = MaterialTheme.colorScheme.onSurface
                                ), shape = when {
                                    options.size == 1 -> RoundedCornerShape(8.dp)
                                    i == 0 -> RoundedCornerShape(topStart = 8.dp, topEnd = 8.dp)
                                    i == options.lastIndex -> RoundedCornerShape(
                                        bottomStart = 8.dp,
                                        bottomEnd = 8.dp
                                    )

                                    else -> RoundedCornerShape(0.dp)
                                }
                            ) {
                                Column(
                                    modifier = Modifier.padding(12.dp),
                                    verticalArrangement = Arrangement.spacedBy(4.dp),
                                ) {
                                    Text(
                                        text = option.title,
                                        style = MaterialTheme.typography.titleMedium,
                                        color = MaterialTheme.colorScheme.primary
                                    )
                                    Text(
                                        text = option.description,
                                        style = MaterialTheme.typography.bodyMedium
                                    )
                                    if (showOptionValues) {
                                        val displayValue = when {
                                            presetLabel != null -> presetLabel
                                            resolvedValue == null -> stringResource(R.string.app_version_unspecified)
                                            resolvedValue is Boolean -> if (resolvedValue) {
                                                stringResource(R.string.option_value_enabled)
                                            } else {
                                                stringResource(R.string.option_value_disabled)
                                            }
                                            resolvedValue is List<*> -> resolvedValue.joinToString(", ") { it.toString() }
                                            else -> resolvedValue.toString()
                                        }
                                        Row(
                                            modifier = Modifier.fillMaxWidth(),
                                            horizontalArrangement = Arrangement.spacedBy(8.dp),
                                            verticalAlignment = Alignment.CenterVertically
                                        ) {
                                            Surface(
                                                color = MaterialTheme.colorScheme.secondaryContainer,
                                                contentColor = MaterialTheme.colorScheme.onSecondaryContainer,
                                                shape = RoundedCornerShape(999.dp)
                                            ) {
                                                Text(
                                                    text = stringResource(R.string.option_value_selected_label),
                                                    style = MaterialTheme.typography.labelSmall,
                                                    modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)
                                                )
                                            }
                                            Text(
                                                text = displayValue,
                                                style = MaterialTheme.typography.labelLarge,
                                                color = MaterialTheme.colorScheme.onSurfaceVariant
                                            )
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun PatchInfoChip(
    modifier: Modifier = Modifier,
    onClick: (() -> Unit)? = null,
    text: String
) {
    val shape = RoundedCornerShape(8.0.dp)
    val cardModifier = if (onClick != null) {
        Modifier
            .clip(shape)
            .clickable(onClick = onClick)
    } else {
        Modifier
    }

    OutlinedCard(
        modifier = modifier.then(cardModifier),
        colors = CardColors(
            containerColor = Color.Transparent,
            contentColor = MaterialTheme.colorScheme.onSurface,
            disabledContainerColor = Color.Transparent,
            disabledContentColor = MaterialTheme.colorScheme.onSurface
        ),
        shape = shape,
        border = BorderStroke(1.dp, MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.20f))
    ) {
        Row(
            modifier = Modifier.padding(8.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.Center
        ) {
            Text(
                text,
                overflow = TextOverflow.Ellipsis,
                softWrap = false,
                style = MaterialTheme.typography.labelLarge,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

const val PACKAGE_ICON = "\uD83D\uDCE6"
const val VERSION_ICON = "\uD83C\uDFAF"

private fun buildSearchUrl(packageName: String, version: String?, searchEngineHost: String): String {
    val encodedPackage = Uri.encode(packageName)
    val encodedVersion = version?.takeIf { it.isNotBlank() }?.let {
        val formatted = if (it.startsWith("v", ignoreCase = true)) it else "v$it"
        Uri.encode(formatted)
    }
    val encodedArch = Build.SUPPORTED_ABIS.firstOrNull()
        ?.takeIf { it.isNotBlank() }
        ?.let(Uri::encode)
    val query = listOfNotNull(encodedPackage, encodedVersion, encodedArch).joinToString("+")
    val host = normalizeSearchHost(searchEngineHost)
    return "https://$host/search?q=$query"
}

private fun normalizeSearchHost(value: String): String {
    val trimmed = value.trim()
    if (trimmed.isBlank()) return "google.com"
    val noScheme = trimmed.removePrefix("https://").removePrefix("http://")
    val noPath = noScheme.substringBefore('/').substringBefore('?').substringBefore('#')
    return noPath.trim().trimEnd('/').ifBlank { "google.com" }
}

private fun PatchInfo.matchesQuery(query: String): Boolean {
    val normalized = query.lowercase()
    if (name.contains(normalized, ignoreCase = true)) return true
    if (description?.contains(normalized, ignoreCase = true) == true) return true
    if (compatiblePackages?.any { pkg ->
            pkg.packageName.contains(normalized, ignoreCase = true) ||
                (pkg.versions?.any { it.contains(normalized, ignoreCase = true) } == true)
        } == true
    ) {
        return true
    }
    if (options?.any { option ->
            option.title.contains(normalized, ignoreCase = true) ||
                option.key.contains(normalized, ignoreCase = true) ||
                option.description.contains(normalized, ignoreCase = true)
        } == true
    ) {
        return true
    }
    return false
}
